# I Tried Google's Hardest Coding Interview (Here's What Happened)

- **頻道**：Tech With Tim
- **平台**：youtube
- **時長**：41 分鐘
- **來源**：https://www.youtube.com/watch?v=8DjDn-YSWaA
- **轉錄方式**：subtitle

## 轉錄內容

Have you ever wondered what a Google coding interview actually looks like? Well, today I'm breaking down the entire Google coding interview process. I'm going to show you exactly how it works, walk through a real problem step by step, and solve it myself live so you can see how to actually approach these questions. And at the end, I'll tell you exactly what I used to prepare for my own technical interviews that got me a job at Microsoft. Okay, let's get into it. Now, before we look at the real problem, let me give you a quick overview of how Google's coding interviews usually work because there's a lot of misinformation out there. Now, Google's interview process typically has a few stages to it. First, there's usually a recruiter screen. This is usually a basic conversation just to see if you're a fit before they move you on. Then, you may have a one or two round phone screen, which typically can be a mix of technical and behavioral interviews, which you'll do remotely. Now, if you pass those, you get invited to the on-site interview, which is usually four to five back-to-back interviews in a single day, physically in person. Now, these coding interviews are usually 45 minutes long. You'll be given one or two algorithmic problems, and you're expected to talk through your thought process, write clean code, and analyze the time and space complexity of your solution. The interviewer isn't just looking at whether you get the right answer. They're evaluating how you think, how you communicate, and how you handle getting stuck. Now, Google uses what they call structured interviewing, which means every candidate is evaluated on the same rubric. So, general cognitive ability, leadership, role related knowledge, and something they call googliness, right? Kind of vague, but this is basically culture fit. How well you kind of fit in and collaborate on a Google team. Now, most of this is pretty standard for big tech interviews, but what makes Google trickier is the bar that they have. They're not just looking for the correct solution. They want optimal solutions, clean code, and clear communication. And you don't just have to do this well, you have to do it better than all of the other candidates. So, you need to nail all three of those. And by the way, Google also has system design interviews, but I'm not going to focus on those in this video. This is going to be more of kind of the problem solving type problems, you know, data structures and algorithms. Now, with that in mind, there's actually something a lot of people don't know. Google actually posted a video on their own YouTube channel showing what their coding interviews look like. Now, it's not a secret. is literally right there publicly available and it's one of the best resources you can use to understand what you're walking into. Now in that video they walk through a mock interview with a real Google engineer who's kind of playing the candidate and another engineer who's playing the interviewer. Now they show this whole thing. So how the problem is introduced, how the candidate asks the questions, etc. How they write the code, test it, optimize. But what I'm going to do is take this exact same problem and solve it myself. So you can see who someone who's not currently a Google engineer and didn't prepare for this, you know, interview that they did, right, actually handles this, which is a little bit more realistic than you're going to get in this video. Now, I'm going to link the Google interview down below so you can watch it. What I'm going to do is just show you the portion where they are asking the question and then I'm going to go ahead and solve it. Now, I've seen problems like this before, but I don't know the solution that I actually went with in this video, and that's intentional. So, I can kind of try to derive that for you and show you exactly how I would go about solving this completely from scratch. Anyways, let's watch part of this video. Let's get the problem, and then I'm going to dive onto the whiteboard, start solving it for you, and then code it out in my code editor. Okay, let's watch this here. Again, I'll put the video in the description. >> Here's my technical question for you. A farmer wants to farm their land with the maximum area where good land is present. The land is represented as a matrix with ones and zeros where ones mean good land and zeros mean bad land. The farmer only wants to farm in a square of good land with the maximum area. Please help the farmer to find a maximum area of the land they can farm in good land. I'll paste the question and that includes an example as well. >> Okay, so I'm going to stop here. They just asked the question. It's pretty clear and then they have an example. Now, in a real interview, let's imagine I'm kind of like starting right now. What I would do is I would start by asking clarifying questions. So, if we just go back just so it's a little bit uh larger so you guys can read this here. I would first of all just repeat this whole question before I would actually dive into solving it. So, I would just read this out myself and just recind of iterate to the interviewer exactly what they asked. So I would say something like, okay, so we're going to have kind of zeros and ones which represents like a plot of land and you're asking for kind of finding a square or I guess like yeah a square with the maximum area of land that is only good land. So does that mean that it could contain any bad land or it has to only be good land? I would wait for the interview to answer. They would tell me it has to just be good land. So the square can only be once. Okay, just to be clear, we're talking about square, right? Not a rectangle. So it has to be equal width, equal height. Yes, it has to be equal width, equal height. Right? I'm kind of playing both sides here, but you need to do this exercise. And actually, there's some things in this prompt that I would need clarified before I'd be able to even move forward. Okay, so that's kind of the first thing I'm asking a few questions. Now, also, what is it that's going to be inputed into my function? Like, what am I uh going to be receiving as an input? Oh, you're going to be receiving a two-dimensional array or two dimensional list in Python with, you know, zeros and ones. Okay, just to be clear, can I assume that all of the values that I receive are only going to be zero or one, or could you throw in something else? No, it's only going to be 01. Okay. In terms of the size of the input, is that going to be square? Is it going to be a rectangle? Do I have any constraints on the size or is it unknown? It's going to be unknown. We don't know if it maybe is empty if we have, you know, a different size. Okay. And the last thing I'm kind of reading through this problem and the one thing I don't understand is actually what you want me to output. So, I know I want to find kind of the square with the maximum amount of gland, but do you want the positions of the square? So like the top left corner, top right corner, or sorry, bottom right corner, or do you want what the largest area is that I could create? Oh, we want you to uh give us the largest area. Okay, perfect. So I think I have an understanding of the problem. What I'm going to do is I'm just going to draw an example. I just want to kind of visualize this and make sure that I can actually find the answer in this example that you gave us. So what I'm going to do, guys, is you're going to see me looking down. I have a whiteboard. I'll put this up on screen and I'm going to do exactly what I would do in a real interview. So when I look at this, it seems obvious to me that this is going to be kind of the answer that we're looking for. Can you just confirm that this is the correct answer? Because at least from what I can see, this is like the largest square 3x3 that I could generate. It is. Okay, cool. So just making sure. And then let's say we had like more ones over here and this formed a rectangle. That wouldn't be the answer, right? Cuz it's not a square. Okay, cool. So I think I understand that. So it's really important that I'm looking for a square. Okay, so that's good to know. The first thing that just comes to mind when I see a problem like this is that I know I can kind of brute force this, right? For example, I could try to generate, you know, every possible square of every possible size, you know, that exists in this matrix. I can generate all of the squares of, you know, size 5x5 because I know based on the size of this matrix, that's like the largest square I could have. So, I could generate, you know, like these two squares and just check all the positions and see if they're valid. I could then if I didn't find a square of that size, I could try to generate all of the squares of size four, right? Where I would have like this is an option, you know, this is an option. This is an option. You get the idea. We're going to have like, you know, a lot more options. Uh I could try to generate, you know, all of the size three ones and I could look at like all of the potential options that could be a square. Now, that's going to be like highly inefficient. So, I don't think I want to go with that, but it is possible. I could just check, you know, every square that I could possibly do. I also could just check every position and from every position like if this is a one I can just kind of expand outwards and check all of the possible positions and see if these are all ones until I reach a zero and then I can kind of find the square. So that's like kind of the brute force approach. But I don't think that's going to be an optimal approach because well that's just going to take so long. It's going to be you know like some crazy uh quadratic time complexity which is not uh not what I'm looking for exponential time complexity. So I need to think of kind of a more clever way about solving this. Now the first thing that I kind of want to do is I just want to run through the values here and see if I can find kind of any relationship if I was going to be like looping over them. So what I could do is if like I'm looking at one entry here. If this is a zero then I know that this can't make up the square, right? So if it's a zero I can kind of effectively like cross it out. Now if it's a one I know that at minimum I can make a square of area one. So, I could kind of mark like, you know, area one as the maximum size and maybe put like a one beside this or something. And then what I would have to do is if I wanted to check if I could make a bigger square is I would have to look to the right down and to the corner because I need all three of these values to be ones in order to make a square. So, if I were to analyze these three values here, I would see 1 0 1, which it' indicate to me I can't make a square bigger than area 1 using this particular entry because well, I don't have the correct values beside it. So that's one thing I could do is I could kind of take like the minimum of the values around me and I could loop through, you know, step by step. So we kind of mark that as okay, area one is the max. Now this would be the same, right? If I'm looking like to the right here, here I would say like this is, you know, maximum size one. And in fact, we could kind of just skip through these because they're all going to be like that until eventually we get to this position. Now, if I'm in this position, I can kind of see like, all right, I know I can make a square now. and the area would be four. So I'm just going to put a two to say like you know the height and the width of the square is two because these are all ones. But I need to find like the largest area. Okay. So if I go to the next one then kind of same process. I would check you know all of these values and I would say okay well like I can make a square here but that's not going to account for the square I had previously. Okay let me just keep going. I I think I'm kind of on to something but I need to run through a few examples. So if I look at this one, right, then I want to kind of store or mark, okay, I can make a square with this that's like size two, right? Because I I know that I can do that. Now, with this one, it would be the same thing, size two. With this one, cuz I'm only looking to the right, I wouldn't be able to make any square because these are zero. So I would just mark this as size one. Now, this one is where it gets interesting because I can make a square for sure down here, too. But then this was also able to make a square of size two. And then this would be like the full square that could be included. So I know that there's there's some kind of approach here where I can use some kind of dynamic programming where I can essentially store kind of something on the diagonals because when I think of a square, I know that I have like a top leftand corner and a bottom right hand corner or I could go, you know, opposite direction, but I think it makes sense to go kind of left from right, you know, top to bottom. So in order for me to make a square, I just effectively need to identify kind of the two bounds of the square, right? The top left and the bottom right. And in this case, that would be this. However, if I try to do it kind of top down where like I I start here and and try to find all the values that could be in the square, I think that's a bit problematic because what I'm effectively doing is I'm like going to be looking down in the matrix and then I'm going to repeat like computation. So like if I'm here and I want to find the square, I have to look at like all of these values and then I'm here, I'm like reooking at the same values that I've already kind of computed that are a part of this square. So it doesn't make sense for me to kind of do it in that way. What I'm almost thinking is that I can do it kind of like in a reverse order. So for example, like if I was here, I know that I could like make a square with this, for example. If I knew that I could make a square with this, and I knew that I could make a square with this, then I know that I can make a square with all of these, right? So if I were to look at like this value, this value, and this value, and all of those are able to make a square of like a certain size, then I know I can make a square of one larger size by just including this additional value because these cover all the values above it. Okay, that's interesting. Let me try something like that where we do like kind of this reverse diagonal approach and store some values. Then we can look at the exact implementation. Let's just skip row one. Okay. So from here what I would do now I would be looking to the left, top left and up to effectively see okay are any of these values one and can I make a square? But I know that I can't make a square going kind of to the left in column one because there's not going to be any rows to the left of it. So I can effectively just eliminate checking row one because there's no need to really even look at that, right? Although I'm going to need to kind of mark if I can make like a one by one square based on how I'm going to do this. Okay, so let's let's keep uh column one in. So if I look at this value, I know just because there's nothing to the left or, you know, up above it that the maximum size square I can make is one. So I'm just going to put one there. And I would imagine I'd be like storing these in an array or like a matrix or something. I'm going to look at the next value. And for here now, I got to check these three values. And essentially what I'm going to do is I'm going to look at the values that I have stored for these on like the largest square that these could create and take the minimum of that. So in this case I have like one, one, and zero because I can't make a square with this. I can make a one by one with this and a one by one with this. So the minimum of that is going to be zero, right? So I would put a zero. But because we can always make a one by one, I'm just going to put a one. Okay. Then we go to the next value. Same thing. It's a zero. So I know that this can't be a square. So I just put a zero because well there's there's nothing to do there. And then this one. Same thing. I'm looking here, here, and here. And I'm just going to end up putting a one because well this is a one, right? And I can't make a square. Now, this is the first time when I can make a square with this as like the bottom right hand corner. So, what I do is I check these three values and I see that they're all ones. So, that indicates to me that okay, well, if I can make a square with all of the values that are above me, to the left of me, and diagonally above, then I can make a square that's larger if I include this value. So now I'm going to write two here to indicate that this could be the bottom right hand corner of a square of size two that includes you know the top left position as the top left corner of the square. So I've effectively kind of identified the diagonals here if that makes sense which is kind of what I'm aiming to do. Okay, so that's good. So that I think I mean this seems to be working based on how I have it now. kind of like identified that I could have that square and even if I wanted the positions later, I could get that because I could find this largest value and just go up the diagonal even further to find where the square is formed based on the size that I'm storing. Hopefully that makes sense. So now let's go to this next value. Now, same thing actually here. So this is where it gets a bit weird. I have let's change it to another color. I have this where I have one one two. So my rule is kind of like, all right, if I have all the ones there, I got to take the minimum and add one to it for the size of the square that I could create using this as the bottom right hand corner. So this would then be two because while this could make a square of two, because the other ones can't make squares of two, they're just squares of one. Well, I can add one to the minimum and then I get a square of two. So effectively, this is the square that we kind of generated or found out by adding that there. Okay, awesome. I'm getting somewhere. First, this is zero again cuz that's zero. Now, this one again, we're just looking to the left, right? Because that's kind of how we're doing it. So, this is going to be this would be one. And actually, this needs to be fixed to one as well. Okay? Then this, these are all ones, right? So, because they're all ones, I add one to the minimum value, which is one, which gives me two. And that generates this square. Then I go here, and now I'm looking at again these three values, and I see 2 1. So, I know 1 plus 1 cuz minimum plus this is going to be two. And then I go here and this is where it gets interesting and where I think I found the solution. So because all of these are two, I know that if all the values above me can create squares of size two, then if I were to include this value, I can make a square of one size larger, which is three. So then I can write three here. So now all I have to do is kind of just track the position of the largest size square that I could make if I care about this position. But in this case, we just care about the area. So I would just kind of store this in like some you know max value equals three. So I'm storing like the height or you know the width of the square. Okay. And then we go to the next value which would be now again just one. All of those don't matter because they're zero. And now I've identified that this is the area. If I wanted the position later I would have that. And then I would just multiply this by itself. So just put it to the power of two. And I would say the area of the max square is 9. I don't think there's really any edge cases where this can fall apart. The only situation I would want to consider is like empty array or all zero values or yeah that's that's really all I can think of for now and I think that's going to work. Now in terms of the complexity of this I mean it's going to be just a linear time solution because I just need to look through every position one time. I'm not you know recomputing any values. However, right now with all of these numbers that I'm storing like the zeros and the ones I will need some kind of data structure. So probably like a 2D array to store them. So the rate is going to be the same size as this. So if we say this is like m by n. So m width n height or h* w maybe is better. So let's go h ww. Then I'm going to have you know h * w storage. But what I'm kind of realizing actually is that I don't even need to store like let's say I'm on this for example. I don't ever look at these values. I'm only ever looking like one row up, right? And then whatever's to the left of me. So I really only need to store 2 * W rows of data because I only need the one above me. So if it's 2 * W, then that means I'm I can just cut this down to W storage, which is going to be a lot more efficient. So my time complexity will be big O of W * H and my space complexity will be big O of W. We'll have to look in the code to make sure that's accurate. But how does that sound to you? Is this solution kind of making sense what I what I've proposed here? Good. So again, I'm asking the interviewer, right? And to be honest, I probably should have asked the interviewer or made sure they were kind of following along with me a little bit more, but obviously they're not beside me. So, I'm doing it a lot more individually than I normally would. But you can see how I've kind of like started from a brute force approach. I've moved through like a diff some different iterations in my head where like some worked, some didn't work. I had not necessarily some failures, but kind of this like exploration phase where I was like coming up with the answer. Right? So, now I kind of know the conceptual approach that I'm going to follow. I also have done some analysis to figure out okay well that's going to be a pretty efficient solution. I've verified what an interviewer that you know they're going to say oh yeah that makes sense that's efficient. I can't really think of anything more efficient. So now I've used about 15 minutes and I'm going to start actually coding and the coding is going to be relatively easy as you'll see because I have the conceptual overview done. Now even one step I would do before I go even further is I would just write a quick like kind of by hand algorithm. So essentially you know like loop right check you know left three pause okay take min square size right okay update current you know position right or update current value whatever and then track max and return. That's like overall kind of what I need to do. Again, we'll formalize this in the code, but that's the conceptual overview. So, hopefully at this point, the interviewer is going to be happy with my overview. To be honest, I think I did a pretty good job there. That's pretty fast to get to the solution, I would say. Generally, uh, now let's go to the computer and let's kind of code this out. And keep in mind while you're coding, you might run into issues. That's fine. You can always refer back to the whiteboard and do those visualizations, but I like to draw it out visually like this because it makes it a lot easier to see. Okay, so let's dive into the code walkthrough. Now, this is going to be interesting for me because I don't really write code manual anymore. I use AI a lot. So, let's see how fluent I am at at typing the code out here. But what I'm going to do is effectively just try to generate the solution. At this point, I would have spent maybe 20 minutes going through the overview, whatever. And typically, you have 45 minutes in the interview. So, if I can try to get the code done here in like 15 minutes, that's a good target. And then that leaves me like 5 10 minutes at the end for any questions, optimizations, um you know, analyzing the solution, walking through it line by line. So obviously we'll go as fast as possible, but it's more important that you explain what you're doing line by line so that the interviewer can follow along with you and that you write clean code. So again, always keep track of your time. That's why I'm telling you what my time is. I also obviously am spending a bit of time here like breaking down what I'm doing, which I wouldn't do in an interview, you know, as verbosely. Okay, so let's get into it. So again, this is kind of like max area. So I'm just going to define a function like max area. Now the inputs, again, the interviewer is going to give this to you. It's just going to be essentially land, right? And I want to make sure I'm using good variable names. So first thing I want to do is I just want to check the edge case. So I'm just going to say edge case, you know, slash empty land. And I'm going to say if the len of land is less than two then what I'm going to do is just return the len of lent. Now the reason why I can do this is because if the length is less than two then it's either zero or one which means well if the length is that the maximum size square I could have is whatever the size of the array is right. So either one or zero. So let's just handle that edge case. And then let's just do the same thing. We're going to say if the len of land at index zero and I know this is a valid check because I've checked now if we have enough rows effectively or enough height is less than two then same thing we just can return this and in fact we're going to use these values again. So let's just go you know height is equal to this right and then we can change this to be height which is going to be a little bit easier to read. And then down here we're going to go width is equal to this. And I should have asked and I'm gonna ask now because I forgot. I just want to make sure the array is going to be uniform. So it's always going to be like rectangular. We're not going to have values kind of outside of the bounds if you know what I mean. I'm asked to interview this. Yeah, it's going to be rectangular. Okay, perfect. So that makes my life a lot easier in terms of doing these checks. Okay, so there we go. We have kind of the width and the height. We've handled the edge case. Uh now we want to get into the looping. Now again, the the main data structure we're going to use here is just effectively two rows that we want to store. And now that I think about it, I don't even need two full rows. I just need to know the element besides me's value for the largest square we could create as that as the bottom right hand corner and the top row. So I'm going to go, you know, max square size. I I would like a better variable name, but I think for now this is fine just in the name of time. So max square size, that's going to be my kind of dynamic programming array. And I'm going to go, you know, max square size left. And actually, let's go above um row above. Okay. And the max square size left is equal to zero. And then what we're going to do here is I'm just going to say 04 I in range and this is going to be the width. So that's going to give me the two data structures I need. So we can say, you know, DP storage. Okay. Okay. And then we're going to get into the actual algorithm. So for the actual algorithm, what I need to do, let's make this a bit smaller, is I need to loop through every position. So I'm going to say four and this is going to be row in and this is just going to be bland. And then I'm going to say for and we need to oh actually I'm going to have to enumerate this because I'm going to need to know the current row that I'm on. So I'm going to say for i, row in enumerate land. And then I'm going to say for J comm, and we're going to go land value in enumerate. And this is going to be land or actually not land, this is going to be the row. Okay. So this is going to give me the position. So I J and uh what do you call it? Um yeah, the the value. Okay. Now that we have that, what we want to do is we need to just first check if this value is zero. So, we're going to say if land value is equal to zero, then we can just continue because this is bad land. And there's nothing we need to really do um if there's bad lands except we should update this max storage size left to be zero because that's going to be the value we were just on that we're going to look at in the future. So, we're just going to say max square size left uh is equal to zero. Okay, cool. Now, otherwise, right, and we don't need to write the else because we have the continue. Then, what we can do is we can check the current value. So, we're going to know it's one at this point. So, what we need to do now is need to look we need to look in those three positions, right? Up, left, and above. And we essentially need to see if all of those values are going to be, and we're checking in this array, by the way, if all of those values are going to be something greater than zero. Now, we need to make sure that we're not in the first row when we do this. So, here's what we want to do. We're going to say if I is equal to zero, so if we're in row zero, then we're not going to be able to update this. So, essentially, same thing. We're going to say continue, but we're going to say the max square size left is equal to one. The reason why I'm doing this is essentially I want to update the correct value, but I don't need to start updating this yet. H I'm just trying to think of how I want to do this um so that it's getting so it's going to be correct because in the first row it's a little bit tricky. I guess we're not updating this. Yeah, because this is above. So right now this is all zero and then we go below but this needs to be updated so that when we go down we can look at it above. Yeah the values left. So I think actually I was wrong with this like we just need to store the thing to left. I don't think that's going to be possible. I think we're going to have to store um two rows and then that's going to make this a little bit easier for us. So you guys can see I'm struggling a little bit with the coding because I'm again I'm not uh I don't do this like manual coding as often. So this would be something I would definitely want to practice for getting in the interview. But I realize now that I'm going to have to store more. So I'm going to go like this and I'm going to make an array. And I'm going to say an array of zero for and this is going to be J in range. And then this is so actually need to change this for and we actually just do underscore for underscore in range of and actually we don't need range. We can just say that this is the width because we already have that variable. And then we can say for underscore in height. So this should now make that uh DP array for us. But for height we can actually just put can just put two for underscore and this needs to be range in range 2 and in range width. Okay. So I'm going to just not do this for now and after we'll look at optimizing it. I'm just going to store the whole thing because if I start trying to do this optimization I realize I'm going to have to copy rows down into different values and it's going to make it a little bit more complex. So we can again look at that in a second. Um but for now let's avoid the complexity just so I can get a solution down and then we we can look at changing this data structure which I I kind of think um you know we're going to have to do. Okay, so if the land value is zero, you know, there's nothing that we really need to do, but we should update the current position to say zero, right? So if that's the case, then we're going to say, you know, the max square size and this is going to be at i and then j is equal to zero. Otherwise, uh what we need to do is check all of the positions, right? So again, same thing. Positions is equal to this. We're going to say if if I does not equal zero then what we're going to do is say positions and we're going to say dotappend and we're going to append the top left and the directly above. Same thing for checking the top left. That's going to be difficult. Okay. But let's say if I does not equal zero then we can know we can append at least directly above us. So we're going to say that we're going to take the max square row size above of I minus one and then J. Okay. Then we're going to say if J does not equal zero, then we know we can go diagonally top left. So then same thing, we're going to say positions.append. And then this is going to be I minus one J minus one top left diagonal. Actually this can go here. We're just going to do some more compound conditions because these are all unique. So and I does not equal zero. If J does not equal zero, and I'm pretty sure I can clean up these conditions, which we'll do in a second. Then we're going to say positions.append and then same thing, max square row size. Okay. And then this is going to be I and then J minus one. Yeah. So this is fine to go in here. That's fine for now. I think that's good. Perfect. And let's add a comment left. Okay. Top left. Okay. And then right. And then what we're going to do is we're going to say max square above or actually we're going to say min square above is equal to the minimum of the positions. And then we're going to update our current position to be 1 + that. Okay. So we're going to say the max square size row above at i j is equal to 1 + the min square above. And then we're going to say we need another variable here. We're going to say max size found, okay, is equal to zero. And we're going to say the max size found is equal to the maximum of the max size found. And the max square size max square above. Okay, I think that's going to be good. And then down here, I think we can literally just return the max size found. I got to walk through this because I'm not 100% sure. And again, you guys are seeing my rusty coding from from hand here. I literally have not done this in like a year. So, let's walk through it and see. All right, we check the edge cases. That's fine, right? So, we can just immediately get those out if we need to. We set up this array. Yeah. And I just want to that's the thing I want to check is that we're updating the positions correctly. So, we have the max size row above which is going to store the maximum size square we could use with this as the bottom right hand corner of the square. This is then the answer essentially the max size found. We're looping through the rows and the columns. That looks correct. We're checking the land value if the land value is zero. And actually, we don't need to update it because it's already going to be zero because we already have that populated. So, we just remove that. Then, we're going to get all the positions that we need to check, right? And all of the positions that we need to check are going to be ah, so this is, I think, the one that I need to check because yeah, what I'm struggling with here is that, you know, if we don't have three valid positions, then there's no way that we can have a square. So, I think I just need to go and just do the ifs. I don't I don't like chaining the ifs, but we should just have all three of those because if we don't check all three of those, then there's no reason to update it. So, I'm going to say, yeah, we can just do this. If I does not equal zero and J does not equal zero, then we just do all the positions. And then otherwise, there's no need to do any other checks because if we don't have three positions, there's no way we can make the square, right? However, we should update this to be a one. Yeah. Okay. Okay, so we're going to say max row square size above you know I J is equal to one and we can just put this here and we can say otherwise so if it's a one right so if the land value is one and we don't have three valid positions it would allow this to be a size greater than one then we just make it one so it's updated in the in the array right and then otherwise we're going to check that right so we're going to say main square size above we're going to check the position see okay could all of those positions make a square of some size and then we get whatever the value is. It's either going to be zero or it's going to be one for all of them or two or three or something larger. We're then going to update the current value to be one plus whatever that minimum is and then update the maximum size. Okay. So, what I'm going to do now is just put in the uh lands whatever like this. And let's create an example based on the example that they had. I'm just going to fast forward through creating this and let's run it and see if it works. Okay, so I just wrote the example. Before I run this, I just want to do another pass to make sure this is good. So, first thing I realize I'm returning max size found. I should just put this to the power of two. Uh, or just multiply it by itself. So, we can just do that, you know, max size found. Uh, just because we want to get the area, not just the size. I also realize that positions here is that we only need to do this if this isn't the case. So, here we could just put a continue because there's no reason to uh to update otherwise. Okay, so I think that's fine. Let's run this now and see if we get the correct output. And max square above is not defined. This is what we need to put. Sorry. So, let's put that here, which we could put in a variable, but that's fine. Okay. And let's run this again. Python. And we get a size nine. Okay. Cool. So, it worked on that example. Now, uh that was again just a small mistake. Like if you make a small mistake in the interview, it's fine because again, you're not in the editor and uh you're going to be writing it by hand. So, they're going to like excuse that if you know mistype a variable or something. Now, what I want to do is just change the input a little bit and just see if we can get this to work with a larger one. So, let's just make this like even bigger and just see if this gives us a larger size. So, this should give us 12 now. Um, or 16, sorry, not 12. So, let's go same thing. And perfect. Okay, we got 16. And then let's just go like this and see if it still gives us nine. And oh no, I need to just remove one more. Okay, let's do this again. Python 9. Okay, nice. So, looks like that's working. All right, so now at this point, if I was confident that the solution is working, what I would want to do is analyze this for the space and time complexity. And then talk about any optimizations I could make if I had time. And here, I probably would actually have time to make an optimization where again, I don't need to store all of the rows. I could just store two rows. However, that's going to sacrifice a little bit of time complexity. Well, let's see if I wanted to do that. So, let's just analyze the solution as it is. These here are constant time operations. This operation is going to take so let's do it in big annotation O of N or O of H * W because we need to recreate essentially a new array for uh storing all the values for the land. That's and actually I think there's even a way we can make this more optimized which we'll talk about in a second. This is constant time operation. These here right is going to end up being again big O of H* W because we're looping through everything inside of here. All of these are constant time operations. Sure, we're calculating, you know, the min and the max of some values, but it's just constant values, which is three. So that just leads me to believe the time complexity is going to be bigo of h* w, which I know for a fact we cannot improve on because that's the minimum time complexity to analyze all of the elements. Now, what I am noticing is that while we've created this max square size row above, we could actually just do this in place. Now I would have to ask the interviewer if this original array would is okay to be modified. If I can modify it then I can actually reduce any space dependency and use the original array that's passed where I effectively just change all of these to say land. And if I do that then this solution just works the exact same way. So let's actually do that. I think I have like control H and just make this say land. I mean, let's try that. And let's just go control shiftb run with Python. And okay, we got zero. Okay, so maybe not. Maybe we we can't do that. Um, why did I think we could do that? I was pretty sure we were going to be able to do without auxiliary storage, but I think it's because if we're changing it there. H, interesting why that was the case. Anyways, okay, I'm not going to go through that. In a real interview, I probably wouldn't have done that, but I would have, you know, looked through it more in depth. Again, I'm just going off the top of my head with you guys, so I'm I'm just seeing like how we could optimize. But we got the space and the time. So, we know we're using this much time, but also this much space because that's what we're storing. And we know that we're using this much time, you know, bigo of H* W. The only thing I can think now if that didn't work is that we can make this just be two rows because we only ever use two rows at the same time. So if I did change this to be two for example, what I would need to do is I would need to copy the value that was in the last row to the row above after the end of every row analysis. So what I mean by that is and let's try it because again I'm just talking with you guys. It's not the real interview is if I only want to store two rows, right, which I only need to store two rows because I just need the current row that I'm on and then effectively the row above. What I can do, I can just say the max square size row above and this is going to be at zero is equal to the max square size row above at one. That would make sense. Um I believe and that should work. The only issue is with our kind of I J here is that when I'm going kind of negative one, what I'm going to have to just put instead of negative 1 is just zero. So yeah, rather than putting that and then J is fine because the column is going to stay the same. And then same thing rather than J, this is going to be in one. So rather than I is just going to be one. It's going to be one and this is going to be one because I know I'm only ever going to have two rows. And I think that's going to work. I just need to make sure the copying makes sense. So I'm essentially saying, okay, the current row, so zero, right, which is the row above, is going to be equal now to the row that I just analyzed. Once we get past analyzing one row, so we're essentially shifting, if we go, you know, we take one, which is below, and we move it up one, we're just shifting it up. That should make sense. But then we just need to clear this row. So then we need to say this is equal to this, right? 04 underscore in range width. Now that's going to add two row operations. So you know big O of W and big O of W. But these are additive. So big O of W big O of W. And then this one is big O of W as well. So, it's still going to leave us with the same time complexity, but it's going to reduce the space complexity now because we just have the width times two to just be big O of W, which is a lot better, significantly better. So, let's I mean, let's see if that works. Um, so just run this in Python. And did we get the result? We got one. Um, okay. Interesting. So, we've clearly broken something. So, I would need to look at this to optimize it more, but I'm I'm fairly certain that we are able to do this. Okay. So, I think it's because I put zero here when I meant to put one. Yeah, that would make sense. So, let's change this here. Same thing. Run Python. And there we go. We get 16. Okay. So, that's just one little mistake there. I had zero rather than one. Ah, okay. And again, another mistake. This is above. Okay. So, that comments, right? So, 0J above 0 J minus one top left. That makes sense because we're going zero. Yeah. So, up and then to the left. Then this should be directly to the left. So, this needs to be one. and J minus one. So now if we go here and we run this, we get nine. Okay, perfect. So again, just like some small arithmetic errors because of how we were changing this um in an interview, you know, I wouldn't have loved this performance so far at the end part because I'm a little bit kind of all over the place in terms of some of the mistakes because I'm trying to kind of refactor and change the code to be more optimal. But at least the first solution we got was practically perfect. Just a few small mistakes. And then here again like go through it a little bit more fine uh fine tooth comb or whatever you want to call it uh to really pick out all of the small details which I think we just got. And again we were able to reduce the space complexity which would be good. So in Google for sure you would want something like this. I would say overall the code quality is pretty clean. Um you know there is the potential to for example maybe put this into a function just to save us a little bit of readability but overall it's not a long piece of code. The variables are named well. So I think this is totally fine. And there you go. That is how you approach a Google style coding interview problem. Like I mentioned, you ask the clarifying questions, you think through the approach, you come up with an algorithm, you communicate your thinking clearly, and you analyze the complexity at the end. Now, the reason I was able to break this down relatively smoothly isn't because I'm a genius. It's because I've practiced this many times, and I've used tools that really help you build the intuition behind these types of problems. I haven't seen this problem before. I didn't prepare before this video for it as you can probably see based on how I was solving it, but I was able to come up with the answer because of the preparation that I've done. Now, for my preparation personally, I used Algo Expert. Now, that's what allowed me to get a job offer at Microsoft at just 19 years old and various other offers from companies like Shopify. Now, Algo Expert has 200 handpicked coding questions, each with detailed video explanations that are a lot more clear than what I just walked you through right here. They show you not only the solution, but how to think through problems like this, right? It's structured, it's organized, and it actually teaches you the patterns, which is why I was able to do this rather than throwing random problems at you. Now, this is the offer I got after using Algo Expert to prepare. Like, you can check it out for yourself. And right now, they have a special deal where you can get access to everything. So, ALGO expert, systems expert, front-end expert, all of that stuff based on the type of interview you're preparing for, which is worth over $600 now for just $119 for one full year. Now, over 200,000 engineers have used Algo Expert to land jobs at top tech companies. And if you're serious about passing your technical interviews, then this is the resource I'd recommend. And I liked it so much that I actually ended up joining the team at Algo Expert after passing interviews using the product. and I now teach some of the interview problems again in a more kind of fluent structured way than what you would have seen here which is off the dome. Now that being said, have a look in the description for the special offer on Algo Expert and I wish you all the best preparing for your technical interviews.
